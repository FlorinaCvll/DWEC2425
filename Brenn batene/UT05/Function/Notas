// Declarar Funciones

• Funciones declarativas
Son funciones definidas con la palabra clave function, y se pueden invocar antes o después de su declaración gracias al hoisting.
    function saludar() {
      console.log("¡Hola!");
    }

• Funciones de expresión
Son funciones definidas como expresiones y no se elevan, por lo que solo se pueden invocar después de su declaración.
    const despedir = function() {
      console.log("¡Adiós!");
    };

• Funcions fleca
Son una sintaxis más compacta para las funciones expresivas y no tienen su propio this.
    const sumar = (a, b) => {
      return a + b;
    };

// Invocar funciones
• Funciones declarativas
    saludar();

• Funciones de expresión
    despedir();

• Funciones flecha
    console.log(sumar(2, 3)); // Output: 5

// Parámetros y Argumentos
• Funcion con Parametros
Los parámetros son valores que se pasan a la función cuando se declara.
    function multiplicar(a, b) {
      return a * b;
    }

• Invocar funcion con Argumentos
Los argumentos son los valores que se pasan a la función cuando se invoca.
    let resultado = multiplicar(4, 5);
    console.log(resultado); // Output: 20

// Anonimas y autoejecutables
• Funciones anónimas
Funciones sin nombre, generalmente usadas como parámetros en métodos de orden superior.
    setTimeout(function() {
      console.log("Esto se ejecuta después de 1 segundo");
    }, 1000);

• Funciones autoejecutables
Función que se declara y se invoca inmediatamente.
    (function() {
      console.log("Esta función se ejecuta inmediatamente");
    })();

// Usos y desusos
1. Funciones Declarativas:
Usar: Cuando necesites definir funciones reutilizables y puedan ser invocadas en cualquier parte del código.
Evitar: En situaciones donde el contexto de this es crítico y quieres evitar problemas de elevación.

2. Funciones Expresivas:
Usar: Cuando necesites funciones locales a un bloque de código específico.
Evitar: En situaciones donde necesites invocar la función antes de su definición.

3. Funciones Flecha:
Usar: Para funciones cortas y como callbacks donde el uso de this debe referirse al contexto exterior.
Evitar: Cuando necesites una función con su propio this contexto, como en métodos de objetos.

4. Funciones Anónimas
Usar:
   -Callbacks:
    Situación: Cuando necesitas pasar una función como argumento a otra función.
    Ejemplo: Usar una función anónima en métodos como setTimeout, addEventListener, o en métodos de arrays como map, filter y forEach.
    setTimeout(function() {
      console.log("Esto se ejecuta después de 1 segundo");
    }, 1000);

    [1, 2, 3].forEach(function(num) {
      console.log(num);
    });

    - Funciones de una sola vez:
        Situación: Cuando la función no necesita ser reutilizada y solo se llama desde un punto del código.
        let array = [1, 2, 3];
        array.map(function(num) {
          return num * 2;
        });
Evitar:
    - Depuración Difícil:
        Situación: Las funciones anónimas pueden dificultar la depuración, ya que los nombres de las funciones no aparecen en los rastros de la pila.
        Alternativa: Usar funciones con nombre cuando la legibilidad y la depuración sean una prioridad.
            array.map(function duplicar(num) {
              return num * 2;
            });

    - Reutilización necesaria
        Situación: Si la función necesita ser llamada desde múltiples lugares, es mejor asignarla a una variable o usar una función con nombre.
        Alternativa: Declarar la función antes de usarla.
            function duplicar(num) {
              return num * 2;
            }
            array.map(duplicar);

5. Funciones Autoejecutables
Usar:
    - Encapsulación:
        Situación: Para crear un alcance local y evitar contaminar el alcance global.
        Ejemplo: Usar IIFE para encapsular código dentro de un bloque y mantener variables y funciones privadas.
            (function() {
              let privado = "Este es un valor privado";
              console.log(privado);
            })();

    - Inicialización:
        Situación: Para ejecutar código de inicialización inmediatamente.
        Ejemplo: Configurar variables o inicializar módulos tan pronto como se define el script.
            let modulo = (function() {
              let contador = 0;
              return {
                incrementar: function() {
                  contador++;
                  console.log(contador);
                }
              };
            })();
            modulo.incrementar(); // Output: 1
            modulo.incrementar(); // Output: 2

Evitar:
    - Legibilidad de código:
        Situación: El uso excesivo de IIFE puede hacer que el código sea difícil de leer y mantener.
        Alternativa: Usar funciones con nombre y módulos de ES6 (import/export) para organizar el código.
            function modulo() {
              let contador = 0;
              return {
                incrementar: function() {
                  contador++;
                  console.log(contador);
                }
              };
            }
            let miModulo = modulo();
            miModulo.incrementar(); // Output: 1
            miModulo.incrementar(); // Output: 2

